import pandas
import pandas as pd
import numpy as np
from scipy.interpolate import interp1d
from scipy.integrate import quad
import warnings

"""Script is used to calculate combined profile area for a single profile. To be called by the check profile cross mp 
   script to recalculate CPA on the fly"""

# Function to fetch data from the database
def get_data(query, conn):
    """Fetch data from the database and return as a pandas DataFrame"""
    return pd.read_sql_query(query, conn)

class CalculateCPATool:


    def __init__(self,  survey_unit:str ,profile:str , master_profile_data, new_profile_data:pandas.DataFrame, survey_date):

        self.survey_unit = survey_unit
        self.profile = profile  # the profile selected
        self.master_profile_data = master_profile_data  # filtered mp profile for the profile
        self.profile_data = new_profile_data # the new edited profile data generated by the profile qc tool



        self.date  = survey_date

        print(self.date)
    def calculate_cpa(self):

        def extract_chainage_elevation(master_profile_data):
            """Function Extracts MP data chainage and elevation values"""

            chainage_values =  list(master_profile_data['chainage'])
            elevation_values = list(master_profile_data['elevation'])

            return chainage_values, elevation_values

        def filter_df_for_master_profile(df: object, start_chainage: float, end_chainage: float,
                                         section_elevation: float):
            """Function filters the target profile df for data within the bounds of the master profile.
            This is achieved by removing all elevation data below MLSW and corresponding chainage. Then removing all
            chainage and corresponding elevation data lower than the upper chainage limit (the master profile start chainag
            Need to factor in removing elevation values that are above MLSW but after where the elevation has dipped below
            ML

            Returns x: filtered chainage, y: filtered elevation
            """

            # Extract Numpy arrays of the chainage and elevation data
            chainage = df["chainage"].values
            elevation = df["elevation"].values

            # Create an interpolation function - interpolate the data to get more points
            interpolation_func = interp1d(chainage, elevation, kind="linear")

            # Create an array of x values for interpolation- get the values of the interpolated data (set to 200 points)
            global interpolated_x_values
            interpolated_x_values = np.linspace(min(chainage), max(chainage), num=5000)

            # Use the interpolation function to get y values
            global interpolated_y_values
            interpolated_y_values = interpolation_func(interpolated_x_values)

            # filter the interpolation values for the mlsw - elevation on the y-axis:
            filtered_elevation_indices = interpolated_y_values >= section_elevation
            filtered_chainage_lower = interpolated_x_values[filtered_elevation_indices]
            filtered_elevation_lower = interpolated_y_values[filtered_elevation_indices]

            # filter for lower chainage limit - chainage on the x-axis
            filtered_chainage_indices = filtered_chainage_lower >= start_chainage
            filtered_chainage_upper = filtered_chainage_lower[filtered_chainage_indices]
            filtered_elevation_upper = filtered_elevation_lower[filtered_chainage_indices]

            # filter for upper section chainage limit - chainage on the x-axis
            filtered_chainage_indices = filtered_chainage_upper <= end_chainage
            filtered_chainage_upper1 = filtered_chainage_upper[filtered_chainage_indices]
            filtered_elevation_upper1 = filtered_elevation_upper[filtered_chainage_indices]

            # clean the namespace setting the filtered data to a better name
            filtered_chainage = filtered_chainage_upper1
            filtered_elevation = filtered_elevation_upper1

            return filtered_chainage, filtered_elevation

        def calculate_area(x_values: object, y_values: object, start_x: float, baseline_y: float):
            """Calculate the area under the curve starting from a specific x-value and using a baseline y-value"""
            with warnings.catch_warnings():
                warnings.simplefilter("ignore")

                def integrand(x):
                    return baseline_y - np.interp(x, x_values, y_values)

                area, _ = quad(integrand, start_x, max(x_values))
                return area

        def get_area(df, target_profile):
            """Function extracts the area for the given input params and plots the profile sections."""

            total_area = []  # holds the area calculations for each profile section
            plot_data = []  # holds data for plotting sections

            # filter the df of all data for survey unit for the specific profile and date
            filter_df_for_profile = df

            # Get chainage data for profile, check if exists
            master_profile_xy = extract_chainage_elevation(self.master_profile_data)
            if master_profile_xy:

                master_profile_chainage = master_profile_xy[0]
                master_profile_elevation = master_profile_xy[1]
                zipped_master_profile_data = list(
                    zip(master_profile_chainage, master_profile_elevation)
                )

                # create the sections to calculate area for
                sections = [
                    (zipped_master_profile_data[i], zipped_master_profile_data[i + 1])
                    for i in range(len(zipped_master_profile_data) - 1)
                ]

                # iterate over each xy pair for master profile chainage and elevation
                section_count = 0
                for section_data in sections:
                    section_count += 1
                    start_chainage = section_data[0][0]
                    end_chainage = section_data[1][0]
                    section_elevation = section_data[0][1]

                    # filter the df for section
                    filtered_chainage, filtered_elevation = filter_df_for_master_profile(
                        df=filter_df_for_profile,
                        start_chainage=start_chainage,
                        end_chainage=end_chainage,
                        section_elevation=section_elevation,
                    )

                    # check if any data found in section before calculating area
                    if len(filtered_chainage) > 0:
                        area = abs(
                            calculate_area(
                                filtered_chainage,
                                filtered_elevation,
                                min(filtered_chainage),
                                section_elevation,
                            )
                        )
                        total_area.append(area)

                        # store data for plotting
                        plot_data.append(
                            (filtered_chainage, filtered_elevation, section_elevation, section_elevation, section_count)
                        )
                    else:
                        print(f'Missing Area Calculation for section {target_profile}')

                # --- Call plot once after all sections are processed ---
                if plot_data:
                    pass
                    #plot_cpa_sections(plot_data, target_profile)

            else:
                print(f"Master Profile data not found for {target_profile}. Skipping.")
                return None

            return sum(total_area)



        def get_csa_data():
            area = get_area(df=self.profile_data, target_profile=self.profile)

            new_cpa_data = {'Survey_Unit': [self.survey_unit], 'Date': [self.date], 'Profile':[self.profile], 'Area':[area]}
            to_df = pd.DataFrame.from_dict(new_cpa_data)

            return to_df

        recalulated_cpa_data = get_csa_data()
        print(recalulated_cpa_data)

        return recalulated_cpa_data

